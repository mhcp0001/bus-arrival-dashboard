# 自宅最寄バス停リアルタイム到着情報ダッシュボード 詳細設計仕様書（改訂版）

## 1. システム概要
### 1.1 目的
自宅（野崎）から出発する小田急バスの情報を、指定の4つの目的地（三鷹駅、吉祥寺駅、武蔵境駅南口、調布駅北口）ごとにリアルタイムで取得し、Webダッシュボード上に一覧表示する。

### 1.2 対象ユーザー
自宅周辺でバスを利用するユーザー

### 1.3 主な機能
- 小田急バス情報システムからデータを取得（API優先、スクレイピングは代替手段として検討）
- 各目的地ごとのバス情報（バス番号、発車予定時刻、発車予測時刻、停留場番号、終点到着予定時刻、及び「約〇分で発車します」から抽出した数値）をデータベースに保存
- REST API（JSON形式）を通じ、フロントエンドへ最新情報を提供
- シンプルかつレスポンシブなフロントエンドで情報を一覧表示（Ajaxポーリングによる自動更新）
- 適切な更新スケジュール実行およびエラーハンドリング・ログ出力
- 将来的な拡張として、通知機能や天気・JR/京王線情報などの外部連携

## 2. システムアーキテクチャ
### 2.1 全体構成
#### バックエンド
- 言語：Python
- Webフレームワーク：Flask（シンプルな実装のため）
- データ取得：公式API優先、代替としてrequests + BeautifulSoupを使用
- データベース：SQLite（開発・個人利用）または PostgreSQL（拡張時）
- 定期実行：APScheduler を用いて適切な間隔でデータ取得処理を実行
- API：RESTfulエンドポイント（HTTPS対応）
- ログ出力：Python 標準の logging モジュールを使用

#### フロントエンド
- 実装：HTML/CSS/JavaScript（レスポンシブデザイン）
- フレームワーク：Vue.js または React（コンポーネント化によるメンテナンス性向上）
- 更新方法：Ajaxによる定期ポーリング
- アクセシビリティ：WCAG 2.1 AA準拠

#### デプロイ
- 環境：Ubuntuサーバー
- コンテナ化：Dockerコンテナおよび Docker Compose
- HTTPS：Lets Encryptによる証明書実装

### 2.2 モジュール構成
#### バス情報取得モジュール
1. 公式API調査・活用
   - 小田急バスが提供する公式APIまたはオープンデータの有無を調査
   - 利用可能な場合は、APIクライアントを実装

2. スクレイピングモジュール（APIが利用できない場合の代替手段）
   - 対象URL：各目的地ごとのURL（from=野崎、to=各目的地）
   - 適切なUser-Agentの設定
   - 抽出対象：バス番号、発車予定/予測時刻、停留場番号、終点到着予定時刻、残り時間
   - 柔軟なセレクタとロバストな正規表現の実装
   - スクレイピング成功判定ロジックの実装

3. データ取得ポリシー
   - 通常時間帯（6:00-24:00）：5分ごとの更新
   - 深夜時間帯（0:00-6:00）：15分ごとの更新または運行状況に応じた調整
   - 対象サイトの利用規約遵守

#### データ永続化モジュール
1. データベースモデル
   ```python
   class BusInfo:
       id: int  # 主キー
       destination: str  # 目的地
       bus_number: str  # バス番号
       stop_number: str  # 停留場番号
       scheduled_departure_time: datetime  # 発車予定時刻
       predicted_departure_time: datetime  # 発車予測時刻
       scheduled_arrival_time: datetime  # 到着予定時刻
       predicted_arrival_time: datetime  # 到着予測時刻
       estimated_departure_minutes: int  # 発車までの予測分数
       is_next_bus: bool  # 次のバスかどうか
       created_at: datetime  # データ取得時刻
       is_active: bool  # 現在有効なデータかどうか
   ```

2. データ保持ポリシー
   - 最新のデータ：常時アクセス可能（is_active=True）
   - 履歴データ：30日間保持
   - 集計データ：長期保存（分析用）

#### APIモジュール
1. エンドポイント：
   - GET /api/bus-info（最新情報取得）
   - GET /api/bus-info/history（過去24時間の履歴）
   - GET /api/system-status（システムステータス）

2. セキュリティ：
   - HTTPS通信の強制
   - APIキー認証（将来的な拡張用）
   - レート制限の実装

3. レスポンスフォーマット（拡張版）：
   ```json
   {
     "update_time": "YYYY-MM-DD HH:MM:SS",
     "system_status": {
       "data_source": "API" or "Scraping" or "Cache" or "Static",
       "last_successful_update": "YYYY-MM-DD HH:MM:SS",
       "health": "OK" or "DEGRADED" or "ERROR"
     },
     "destinations": [
       {
         "destination": "三鷹駅",
         "bus_number": "鷹５２",
         "stop_number": "4",
         "scheduled_departure_time": "14:37",
         "predicted_departure_time": "14:44",
         "scheduled_arrival_time": "14:57",
         "predicted_arrival_time": "14:56",
         "estimated_departure_minutes": 3,
         "is_next_bus": true,
         "delay_status": "ON_TIME" or "DELAYED" or "EARLY"
       },
       // 他の目的地も同様の構造
     ]
   }
   ```

#### スケジューラ
1. 定期実行設定
   - APSchedulerを利用した柔軟な間隔設定
   - 時間帯による頻度調整

2. エラーハンドリング
   - レベル1障害（単発失敗）：3回までリトライ
   - レベル2障害（連続失敗）：キャッシュデータ使用（最大60分）
   - レベル3障害（長時間障害）：静的時刻表データにフォールバック
   - 障害発生時のアラート通知

#### ログ・監視モジュール
1. ログ管理
   - Python標準のloggingモジュールを使用
   - ログレベル：DEBUG, INFO, WARNING, ERROR, CRITICAL
   - ログローテーション：サイズまたは日付ベースで実施

2. システム監視
   - Prometheusによるメトリクス収集（オプション）
   - 重要メトリクス：API応答時間、データ取得成功率、エラー発生頻度
   - ヘルスチェックエンドポイント（/health）の実装

#### フロントエンドモジュール
1. UI/UX設計
   - シンプルで直感的なインターフェース
   - ダークモード/ライトモード対応
   - バス到着予定のタイマー表示（カウントダウン）
   - バス遅延時の視覚的な警告表示

2. レスポンシブデザイン
   - モバイルファースト設計
   - 主要ブラウザ対応（Chrome, Safari, Firefox, Edge）
   - 異なる画面サイズでの最適表示

3. アクセシビリティ
   - WCAG 2.1 AA準拠
   - スクリーンリーダー対応
   - キーボードナビゲーション
   - 高コントラストモード

### 2.3 データ取得方法の詳細
1. 優先順位
   1. 公式API（利用可能な場合）
   2. オープンデータ（GTFSなど、利用可能な場合）
   3. Seleniumを使用した動的コンテンツのスクレイピング（上記が利用できない場合）

2. Seleniumによる動的コンテンツスクレイピングについて
   - JavaScriptで動的に読み込まれるコンテンツを取得するため、Seleniumを使用
   - Chrome/Chromedriverによるヘッドレスブラウザを実装
   - ページの完全な読み込みとJavaScriptの実行を待機する仕組み
   - DOM要素の出現を確実に監視するため、明示的な待機処理を実装

3. スクレイピング実施時の注意点
   - 利用規約の確認と遵守
   - アクセス頻度の適正化（5分以上の間隔を推奨）
   - 適切なHTTPヘッダー設定
   - 構造変更検出機能の実装

4. HTML構造変更への対応
   - 柔軟なセレクタ戦略の実装（複数候補セレクタの適用）
   - 正規表現のロバスト化
   - スクレイピング結果の妥当性検証

## 3. データフロー
### 3.1 データ取得プロセス
1. スケジューラがトリガーとなり、バス情報取得モジュールを実行
2. 公式APIまたはスクレイピングによりデータを取得
3. 取得したデータを検証・整形
4. データベースに保存（最新データとして登録、古いデータはis_active=False）
5. 必要に応じてメモリキャッシュを更新

### 3.2 API処理
1. ユーザーがダッシュボードにアクセスすると、フロントエンドがAPI経由でデータをリクエスト
2. バックエンドは最新のデータをデータベースから取得
3. JSONレスポンスを整形して返却
4. フロントエンドは受け取ったJSONデータを用いて表示を更新

### 3.3 エラーハンドリング
1. 段階的な障害対応
   - レベル1（単発障害）：3回までリトライ後、前回データを使用
   - レベル2（連続障害）：キャッシュデータ使用（最大60分）
   - レベル3（長時間障害）：静的時刻表データにフォールバック

2. 障害通知
   - Eメールまたはチャット通知による管理者アラート
   - ダッシュボード上でのステータス表示
   - 障害レベルに応じた通知頻度の調整

3. 自動回復プロセス
   - スクレイピングパターン自動検出機能
   - 定期的なヘルスチェックとプロセス再起動

## 4. Dockerコンテナ構成
### 4.1 アプリケーションコンテナ
- ベースイメージ：python:3.9-slim
- 必要なパッケージ：Flask, SQLAlchemy, requests, BeautifulSoup4, APScheduler, etc.
- アプリケーション起動：Gunicorn利用

### 4.2 データベースコンテナ
- SQLite（単一ファイル）または PostgreSQL（拡張時）
- データボリュームのマウント設定

### 4.3 リバースプロキシコンテナ
- Nginx利用
- HTTPS設定（Lets Encrypt）
- キャッシュ設定
- セキュリティヘッダー設定

### 4.4 Docker Compose設定
```yaml
version: '3'

services:
  web:
    build: ./app
    restart: always
    volumes:
      - ./app:/app
      - ./logs:/var/log/bus-dashboard
    environment:
      - FLASK_ENV=production
      - DATABASE_URL=sqlite:///bus_data.db
      # 他の環境変数
    depends_on:
      - db
    
  db:
    image: postgres:13-alpine # または単純にSQLiteを使用
    restart: always
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_PASSWORD=secure_password
      - POSTGRES_USER=bus_app
      - POSTGRES_DB=bus_data
      
  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/static:/usr/share/nginx/html
    depends_on:
      - web

volumes:
  postgres_data:
```

## 5. セキュリティ設計
### 5.1 通信セキュリティ
- HTTPS通信の強制（Lets Encryptによる無料証明書）
- 適切なHTTPセキュリティヘッダーの設定
  - Strict-Transport-Security
  - Content-Security-Policy
  - X-Content-Type-Options
  - X-Frame-Options

### 5.2 APIセキュリティ
- 将来的な拡張のためのAPI認証機構（シンプルなAPIキー）
- レート制限の実装（IP別、時間帯別）
- 不正アクセス検知と遮断機能

### 5.3 コンテナセキュリティ
- 最小権限原則に基づくコンテナ実行
- 定期的なセキュリティアップデート適用計画
- 機密情報の環境変数管理

## 6. 開発・テスト計画
### 6.1 開発環境
- ローカル開発環境：Docker Compose使用
- コード管理：Git（GitHub/GitLabなど）
- CI/CD：GitHub Actionsなど（オプション）

### 6.2 テスト戦略
1. 単体テスト
   - データ取得モジュール：様々なHTMLパターンでのテスト
   - 正規表現テスト：エッジケースを含む抽出パターン検証
   - APIレスポンステスト：形式と内容の検証
   - データベース操作のテスト

2. 統合テスト
   - エンドツーエンドのデータフロー検証
   - フロントエンド-バックエンド連携テスト
   - スケジューラーの動作確認

3. シナリオテスト
   - バスがない場合の表示検証
   - 通信障害時の挙動検証
   - データ更新頻度の検証
   - 異常データ入力時の挙動検証

4. 性能テスト
   - 同時アクセス時の応答性
   - 長期運用時のメモリ使用状況
   - データベース肥大化時のパフォーマンス

### 6.3 テスト自動化
- Pytest活用によるテスト自動化
- モックサーバーによるスクレイピングテスト
- E2Eテスト（Selenium/Cypress）によるUIテスト

## 7. 監視・運用設計
### 7.1 システム監視
- ログ分析：定期的なログレビュー
- パフォーマンスメトリクス：
  - API応答時間
  - データ取得成功率
  - エラー発生頻度
  - システムリソース使用状況
- アラート設定：重大なエラーやパフォーマンス低下時に通知

### 7.2 バックアップ戦略
- データベースの定期バックアップ（日次）
- 設定ファイルのバックアップ
- コードのバージョン管理

### 7.3 障害復旧計画
- 障害シナリオ別の対応手順書
- 復旧手順の文書化
- 定期的な復旧テスト

## 8. 将来的な拡張機能
### 8.1 機能拡張計画
1. 通知機能
   - プッシュ通知（ブラウザ通知）
   - メール通知
   - Slack/Discord連携
   - 通知条件のカスタマイズ（例：特定のバスの〇分前に通知）

2. 外部API連携
   - 天気情報：OpenWeatherMapなどのAPI
   - JR/京王線情報：各鉄道事業者のAPI
   - 渋滞情報：Googleマップなどの交通情報API

3. データ分析・予測
   - バス遅延パターン分析
   - 最適出発時刻推奨
   - 履歴データの可視化

### 8.2 スケーラビリティ計画
1. マルチユーザー対応
   - ユーザー認証システム
   - カスタム設定の保存
   - 個別の通知設定

2. バス停/路線の拡張
   - 任意のバス停/路線の追加機能
   - 複数の交通機関対応

3. プラットフォーム拡張
   - モバイルアプリ開発
   - スマートウォッチ対応
   - スマートホーム連携（Alexa, Google Homeなど）

## 9. まとめ・キーポイント
- データ取得の持続可能性を重視した設計（公式APIの検討、適切なスクレイピング間隔）
- データ永続化によるシステム安定性と分析機能の基盤構築
- 段階的なエラーハンドリングによる高い回復性
- セキュリティを考慮した設計（HTTPS, API認証）
- ユーザビリティとアクセシビリティを考慮したフロントエンド
- 包括的なテスト戦略による品質確保
- 監視・運用体制の確立による長期安定運用
- 将来的な拡張性を考慮したモジュール設計

これらの改善により、単なるプロトタイプから本格的な運用システムへと進化させることができます。特に、データ取得方法の持続可能性、データ永続化、エラー処理の強化は最優先で対応すべき項目です。